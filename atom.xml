<?xml version="1.0" encoding="utf-8"?>
<feed xmlns="http://www.w3.org/2005/Atom">
  <title>Hexo</title>
  
  
  <link href="http://example.com/atom.xml" rel="self"/>
  
  <link href="http://example.com/"/>
  <updated>2020-05-06T11:28:24.955Z</updated>
  <id>http://example.com/</id>
  
  <author>
    <name>John Doe</name>
    
  </author>
  
  <generator uri="https://hexo.io/">Hexo</generator>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/01/04/%E7%AC%94%E8%AE%B0/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0/"/>
    <id>http://example.com/2022/01/04/%E7%AC%94%E8%AE%B0/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E7%BA%BF%E7%A8%8B%E6%B1%A0/</id>
    <published>2022-01-04T15:11:12.731Z</published>
    <updated>2020-05-06T11:28:24.955Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/01/04/%E7%AC%94%E8%AE%B0/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B/"/>
    <id>http://example.com/2022/01/04/%E7%AC%94%E8%AE%B0/%E5%A4%9A%E7%BA%BF%E7%A8%8B/%E5%A4%9A%E7%BA%BF%E7%A8%8B/</id>
    <published>2022-01-04T15:11:12.726Z</published>
    <updated>2020-04-28T12:47:57.690Z</updated>
    
    <content type="html"><![CDATA[<p>并行：一起运行，多个cpu一起处理任务<br>并发：不能脱离时间单位，同一时间共同竞争统一cpu</p><p>线程竞争统一资源，导致线程安全问题</p><p>控制线程连接数——&gt;线程池</p><p>多线程的新建方式</p><ol><li><p>new Thread()</p></li><li><p>接口Runnable</p><p>线程同步                                </p><pre><code>线程安全问题    synchronized，同步方法快，同步方法快        类锁加锁的对象是class对象</code></pre></li></ol><p>stop（）导致资源无法正常释放，数据混乱，抢占式<br>join（）线程顺序的执行，插队</p><p>Volatile保证可见性；常见应用场景：一写多读<br>Thread Local为每一个线程提供一个变量的副本，每个线程都有副本，保证线程的隔离，spring事务的时候使用了：每个线程保存自己的连接<br>Thread Local引发内存泄漏<br>Thread Local引发线程不安全，使用的参数是static：存放的是同一个对象的引用</p><p>线程之间的协作<br>    生产者：1–&gt;2<br>    消费者：–&gt;处理<br>使用wait()、notify()等待和通知一定要加锁。拿到对象锁,调用wait()会释放锁，notify()不会</p><p>CounDownLatch<br><img src="G:\笔记\多线程\img\CounDownLatch.png" alt="1587908782567"></p><p>CyclicBarrier</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">private</span> <span class="keyword">static</span> CyclicBarrier barrier</span><br><span class="line">        = <span class="keyword">new</span> CyclicBarrier(<span class="number">4</span>,<span class="keyword">new</span> CollectThread());</span><br></pre></td></tr></table></figure><p>Semaphore<br>acquire()<br>release()</p><p>显示锁：Lock接口，核心方法 lock(),unlock(),tryLock();消耗较大<br>范式：</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">test2</span><span class="params">()</span> </span>&#123;</span><br><span class="line">lock.lock();</span><br><span class="line">        <span class="keyword">try</span> &#123;</span><br><span class="line">        age--;</span><br><span class="line">        &#125; <span class="keyword">finally</span> &#123;</span><br><span class="line">            lock.unlock();</span><br><span class="line">        &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><p>业务产生异常会导致锁无法释放  所以用上</p><p>可重入锁ReentrantLock，公平与非公平<br>ReentrantLock默认非公平<br>独占锁</p><p>ReadWriteLock 读写锁；写锁拿到锁后不能读写，拿到读锁后不能写<br>condition接口；等待通知await()、singnal()<br>用Lock和condition实现等待通知</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;并行：一起运行，多个cpu一起处理任务&lt;br&gt;并发：不能脱离时间单位，同一时间共同竞争统一cpu&lt;/p&gt;
&lt;p&gt;线程竞争统一资源，导致线程安全问题&lt;/p&gt;
&lt;p&gt;控制线程连接数——&amp;gt;线程池&lt;/p&gt;
&lt;p&gt;多线程的新建方式&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;p&gt;new Thr</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/01/04/%E7%AC%94%E8%AE%B0/UI%E5%BC%80%E5%8F%91/%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/"/>
    <id>http://example.com/2022/01/04/%E7%AC%94%E8%AE%B0/UI%E5%BC%80%E5%8F%91/%E5%BC%82%E6%AD%A5%E6%B6%88%E6%81%AF%E5%A4%84%E7%90%86%E6%9C%BA%E5%88%B6/</id>
    <published>2022-01-04T15:11:12.721Z</published>
    <updated>2020-04-06T12:28:36.573Z</updated>
    
    <content type="html"><![CDATA[<p>Android中的异步消息处理主要由4个部分组成：Message、Handle、MessageQueue和Loper</p><ol><li><strong>Message</strong></li></ol><p>​    Message是线程之间传递的消息，它可以在内部携带少量的信息，用于不同线程之间交换数据</p><ol start="2"><li><p><strong>Handle</strong></p><p>处理者，主要用于发送和处理消息。发送消息一般是使用Handle的setMessage（）方法，而发送的消息经过一系列地辗转处理后，最终会传递到Handle的handleMessage（）方法中</p></li><li><p><strong>MessageQueue</strong></p><p>MessageQueue 是消息队列的意思，他主要是用于发送和处理消息的；这部分消息会一直存在消息队列中，等待被处理，每个线程中只会有一个MessageQueue 对象</p></li><li><p><strong>Looper</strong></p><p>Looper是Message的管家，调用Looper的loop()方法后，就会进入到一个无限循环中，然后每当发现MessageQueue中存在一条消息，就会被取出，并传递到Handle的handleMessage()方法中</p></li></ol><p><strong>处理流程</strong></p><p><img src="E:\笔记\img\异步消息处理机制流程示意图.png" alt="1555565772732"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Android中的异步消息处理主要由4个部分组成：Message、Handle、MessageQueue和Loper&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;&lt;strong&gt;Message&lt;/strong&gt;&lt;/li&gt;
&lt;/ol&gt;
&lt;p&gt;​    Message是线程之间传递的消息，它可以</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/01/04/%E7%AC%94%E8%AE%B0/UI%E5%BC%80%E5%8F%91/UI%E6%9B%B4%E6%96%B0/"/>
    <id>http://example.com/2022/01/04/%E7%AC%94%E8%AE%B0/UI%E5%BC%80%E5%8F%91/UI%E6%9B%B4%E6%96%B0/</id>
    <published>2022-01-04T15:11:12.706Z</published>
    <updated>2020-04-06T12:28:36.572Z</updated>
    
    <content type="html"><![CDATA[<p>更新UI要在主线程中进行，在其他线程进行更新的话会崩溃</p><p>Android不允许在子线程中进行UI操作；子线程中进行一些耗时的操作</p><p>解决方案：通过异步消息处理机制</p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;更新UI要在主线程中进行，在其他线程进行更新的话会崩溃&lt;/p&gt;
&lt;p&gt;Android不允许在子线程中进行UI操作；子线程中进行一些耗时的操作&lt;/p&gt;
&lt;p&gt;解决方案：通过异步消息处理机制&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/01/04/%E7%AC%94%E8%AE%B0/UI%E5%BC%80%E5%8F%91/TextView/"/>
    <id>http://example.com/2022/01/04/%E7%AC%94%E8%AE%B0/UI%E5%BC%80%E5%8F%91/TextView/</id>
    <published>2022-01-04T15:11:12.701Z</published>
    <updated>2020-04-06T12:28:36.571Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line">&lt;TextView</span><br><span class="line">       android:id=<span class="string">&quot;@+id/text_view&quot;</span></span><br><span class="line">       android:layout_width=<span class="string">&quot;match_content&quot;</span></span><br><span class="line">       android:layout_height=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">       android:text=<span class="string">&quot;Hello World!&quot;</span></span><br><span class="line">       /&gt;</span><br></pre></td></tr></table></figure><p><strong>android:layout_width</strong>与<strong>android:layout_height</strong>指定高度跟宽度</p><p><strong>match_parent:<strong>与</strong>fill_parent</strong>的意义相同，表示让当前空间大小和父布局的大小一样，也是由父布局决定当前布局的大小</p><p>**wrap_content:**当前控件的大小刚好包含住里面的内容</p><p><strong>android:text：</strong> TextView中显示的文本内容</p><p>TextView 默认是左上角对其；使用<strong>android:gravity</strong>属性设置对齐方式</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br></pre></td><td class="code"><pre><span class="line">android:textSize=<span class="string">&quot;24sp&quot;</span>  设置文字大小</span><br><span class="line">android:textColor=<span class="string">&quot;#00ff00&quot;</span> 设置文字颜色</span><br><span class="line">android:background=<span class="string">&quot;#ccc&quot;</span>  设置背景颜色</span><br><span class="line">android:autoLink=<span class="string">&quot;web&quot;</span>     设置自动识别文本中的链接</span><br></pre></td></tr></table></figure><p><img src="E:\笔记\img\android_autoLink属性值.png" alt="1555395528076"></p><p>  android:autoLink设置是否当文本为URL链接/email/电话号码/map时，文本显示为可点击的链接。可选值(none/web/email/phone/map/all) </p><p>　　android:autoText如果设置，将自动执行输入值的拼写纠正。此处无效果，在显示输入法并输入的时候起作用。<br>　　android:bufferType指定getText()方式取得的文本类别。选项editable 类似于StringBuilder可追加字符， </p><p>　　也就是说getText后可调用append方法设置文本内容。spannable 则可在给定的字符区域使用样式，参见这里1、这里2。 </p><p>　　android:capitalize设置英文字母大写类型。此处无效果，需要弹出输入法才能看得到，参见EditView此属性说明。 </p><p>　　android:cursorVisible设定光标为显示/隐藏，默认显示。 </p><p>　　android:digits设置允许输入哪些字符。如“1234567890.+-*/% ()” </p><p>　　android:drawableBottom在text的下方输出一个drawable，如图片。如果指定一个颜色的话会把text的背景设为该颜色，并且同时和background使用时覆盖后者。 </p><p>　　android:drawableLeft在text的左边输出一个drawable，如图片。 </p><p>　　android:drawablePadding设置text与drawable(图片)的间隔，与drawableLeft、drawableRight、drawableTop、drawableBottom一起使用，可设置为负数，单独使用没有效果。 </p><p>   android:drawableRight在text的右边输出一个drawable。 </p><p>　　android:drawableTop在text的正上方输出一个drawable。 </p><p>　　android:editable设置是否可编辑。 </p><p>　　android:editorExtras设置文本的额外的输入数据。 </p><p>　　android:ellipsize设置当文字过长时,该控件该如何显示。有如下值设置：”start”—?省略号显示在开头;”end”——省略号显示在结尾;”middle”—-省略号显示在中间; </p><p>”marquee” ——以跑马灯的方式显示(动画横向移动) </p><p>　　android:freezesText设置保存文本的内容以及光标的位置。 </p><p>　　android:gravity设置文本位置，如设置成“center”，文本将居中显示。 </p><p>　　android:hintText为空时显示的文字提示信息，可通过textColorHint设置提示信息的颜色。此属性在EditView中使用，但是这里也可以用。 </p><p>　　android:imeOptions附加功能，设置右下角IME动作与编辑框相关的动作，如actionDone右下角将显示一个“完成”，而不设置默认是一个回车符号。这个在EditView中再详细 </p><p>说明，此处无用。 </p><p>　　android:imeActionId设置IME动作ID。 </p><p>　　android:imeActionLabel设置IME动作标签。 </p><p>　　android:includeFontPadding设置文本是否包含顶部和底部额外空白，默认为true。 </p><p>　　android:inputMethod为文本指定输入法，需要完全限定名(完整的包名)。例如：com.google.android.inputmethod.pinyin，但是这里报错找不到。 </p><p>　　android:inputType设置文本的类型，用于帮助输入法显示合适的键盘类型。在EditView中再详细说明，这里无效果。 </p><p>　　android:linksClickable设置链接是否点击连接，即使设置了autoLink。 </p><p>　　android:marqueeRepeatLimit在ellipsize指定marquee的情况下，设置重复滚动的次数，当设置为marquee_forever时表示无限次。 </p><p>　　android:ems设置TextView的宽度为N个字符的宽度。这里测试为一个汉字字符宽度 </p><p>　　android:maxEms设置TextView的宽度为最长为N个字符的宽度。与ems同时使用时覆盖ems选项。 </p><p>　　android:minEms设置TextView的宽度为最短为N个字符的宽度。与ems同时使用时覆盖ems选项。 </p><p>　　android:maxLength限制显示的文本长度，超出部分不显示。 </p><p>　　android:lines设置文本的行数，设置两行就显示两行，即使第二行没有数据。 </p><p>　　android:maxLines设置文本的最大显示行数，与width或者layout_width结合使用，超出部分自动换行，超出行数将不显示。 </p><p>　　android:minLines设置文本的最小行数，与lines类似。 </p><p>　　android:lineSpacingExtra设置行间距。 </p><p>　　android:lineSpacingMultiplier设置行间距的倍数。如”1.2” </p><p>　　android:numeric如果被设置，该TextView有一个数字输入法。此处无用，设置后唯一效果是TextView有点击效果，此属性在EdtiView将详细说明。 </p><p>　　android:password以小点”.”显示文本 </p><p>　　android:phoneNumber设置为电话号码的输入方式。 </p><p>　　android:privateImeOptions设置输入法选项，此处无用，在EditText将进一步讨论。 </p><p>　　android:scrollHorizontally设置文本超出TextView的宽度的情况下，是否出现横拉条。 </p><p>　　android:selectAllOnFocus如果文本是可选择的，让他获取焦点而不是将光标移动为文本的开始位置或者末尾位置。TextView中设置后无效果。 </p><p>　　android:shadowColor指定文本阴影的颜色，需要与shadowRadius一起使用。 </p><pre><code>android:shadowDx设置阴影横向坐标开始位置。 </code></pre><p>　　android:shadowDy设置阴影纵向坐标开始位置。 </p><p>　　android:shadowRadius设置阴影的半径。设置为0.1就变成字体的颜色了，一般设置为3.0的效果比较好。 </p><p>　　android:singleLine设置单行显示。如果和layout_width一起使用，当文本不能全部显示时，后面用“…”来表示。如android:text=”test_ singleLine “     </p><p>android:singleLine=”true” android:layout_width=”20dp”将只显示“t…”。如果不设置singleLine或者设置为false，文本将自动换行 </p><p>　　android:text设置显示文本. </p><p>　　android:textAppearance设置文字外观。如“?android:attr/textAppearanceLargeInverse”这里引用的是系统自带的一个外观，?表示系统是否有这种外观，否则使用默认的 </p><p>外观。可设置的值如下： </p><p>textAppearanceButton/textAppearanceInverse/textAppearanceLarge/textAppearanceLargeInverse/textAppearanceMedium/textAppearanceMediumInverse/textAppearanceSmal </p><p>l/textAppearanceSmallInverse </p><p>　　android:textColor设置文本颜色 </p><p>　　android:textColorHighlight被选中文字的底色，默认为蓝色 </p><p>　　android:textColorHint设置提示信息文字的颜色，默认为灰色。与hint一起使用。 </p><p>　　android:textColorLink文字链接的颜色. </p><p>　　android:textScaleX设置文字之间间隔，默认为1.0f。 </p><p>　　android:textSize设置文字大小，推荐度量单位”sp”，如”15sp” </p><p>　　android:textStyle设置字形[bold(粗体) 0, italic(斜体) 1, bolditalic(又粗又斜) 2] 可以设置一个或多个，用“|”隔开 </p><p>　　android:typeface设置文本字体，必须是以下常量值之一：normal 0, sans 1, serif 2, monospace(等宽字体) 3] </p><p>　　android:height设置文本区域的高度，支持度量单位：px(像素)/dp/sp/in/mm(毫米) </p><p>　　android:maxHeight设置文本区域的最大高度 </p><p>　　android:minHeight设置文本区域的最小高度 </p><p>　　android:width设置文本区域的宽度，支持度量单位：px(像素)/dp/sp/in/mm(毫米)，与layout_width的区别看这里。 </p><p>　　android:maxWidth设置文本区域的最大宽度 </p><p>　　android:minWidth设置文本区域的最小宽度  </p>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/01/04/%E7%AC%94%E8%AE%B0/UI%E5%BC%80%E5%8F%91/EditText/"/>
    <id>http://example.com/2022/01/04/%E7%AC%94%E8%AE%B0/UI%E5%BC%80%E5%8F%91/EditText/</id>
    <published>2022-01-04T15:11:12.681Z</published>
    <updated>2020-04-06T12:28:36.570Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">EditText</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:id</span>=<span class="string">&quot;@+id/edit_text&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_width</span>=<span class="string">&quot;match_parent&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:layout_height</span>=<span class="string">&quot;wrap_content&quot;</span></span></span><br><span class="line"><span class="tag">    <span class="attr">android:hint</span>=<span class="string">&quot;Type something here&quot;</span>  //提示内容</span></span><br><span class="line"><span class="tag">    <span class="attr">android:maxLines</span>=<span class="string">&quot;2&quot;</span> //设置最大行数 /&gt;</span></span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight xml&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/01/04/%E7%AC%94%E8%AE%B0/UI%E5%BC%80%E5%8F%91/Button/"/>
    <id>http://example.com/2022/01/04/%E7%AC%94%E8%AE%B0/UI%E5%BC%80%E5%8F%91/Button/</id>
    <published>2022-01-04T15:11:12.676Z</published>
    <updated>2020-04-06T12:28:36.568Z</updated>
    
    <content type="html"><![CDATA[<figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line">&lt;Button</span><br><span class="line">       android:id=<span class="string">&quot;@+id/button&quot;</span></span><br><span class="line">       android:layout_width=<span class="string">&quot;match_parent&quot;</span></span><br><span class="line">       android:layout_height=<span class="string">&quot;wrap_content&quot;</span></span><br><span class="line">       android:text=<span class="string">&quot;Button&quot;</span>           <span class="comment">//按钮名称</span></span><br><span class="line">       android:textAllCaps=<span class="string">&quot;false&quot;</span>    <span class="comment">//设置文字不全为大写</span></span><br><span class="line">       /&gt;</span><br></pre></td></tr></table></figure><p>Button继承制TextView </p><p><strong>Button 支持的 XML 属性及相关方法</strong></p><table><thead><tr><th>XML 属性</th><th>相关方法</th><th>说明</th></tr></thead><tbody><tr><td>android:clickable</td><td>setClickable(boolean clickable)</td><td>设置是否允许点击。 clickable=true:允许点击 clickable=false:禁止点击</td></tr><tr><td>android:background</td><td>setBackgroundResource(int resid)</td><td>通过资源文件设置背景色。 resid:资源xml文件ID 按钮默认背景为android.R.drawable.btn_default</td></tr><tr><td>android:text</td><td>setText(CharSequence text)</td><td>设置文字</td></tr><tr><td>android:textColor</td><td>setTextColor(int color)</td><td>设置文字颜色</td></tr><tr><td>android:onClick</td><td>setOnClickListener(OnClickListener l)</td><td>设置点击事件</td></tr></tbody></table>]]></content>
    
    
      
      
    <summary type="html">&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutter&quot;&gt;&lt;pre&gt;&lt;span class=&quot;line&quot;&gt;1&lt;/span&gt;&lt;br&gt;&lt;span class=&quot;line&quot;&gt;2&lt;/span&gt;&lt;br&gt;&lt;span class=</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/01/04/%E7%AC%94%E8%AE%B0/UI%E5%BC%80%E5%8F%91/4%E7%A7%8D%E5%9F%BA%E6%9C%AC%E5%B8%83%E5%B1%80/"/>
    <id>http://example.com/2022/01/04/%E7%AC%94%E8%AE%B0/UI%E5%BC%80%E5%8F%91/4%E7%A7%8D%E5%9F%BA%E6%9C%AC%E5%B8%83%E5%B1%80/</id>
    <published>2022-01-04T15:11:12.651Z</published>
    <updated>2020-04-06T12:28:36.568Z</updated>
    
    <content type="html"><![CDATA[<p><img src="E:\笔记\img\布局与控件之间的关系.png" alt="1555400382987"></p><h2 id="1-LinearLayout（线性布局）"><a href="#1-LinearLayout（线性布局）" class="headerlink" title="1. LinearLayout（线性布局）"></a>1. LinearLayout（线性布局）</h2><p>​    将所包含的控件在线性方向上依次排列</p><h2 id="2-RelativeLayout-相对布局"><a href="#2-RelativeLayout-相对布局" class="headerlink" title="2. RelativeLayout(相对布局)"></a>2. RelativeLayout(相对布局)</h2><h2 id="3-FrameLayout（帧布局）"><a href="#3-FrameLayout（帧布局）" class="headerlink" title="3. FrameLayout（帧布局）"></a>3. FrameLayout（帧布局）</h2>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;E:\笔记\img\布局与控件之间的关系.png&quot; alt=&quot;1555400382987&quot;&gt;&lt;/p&gt;
&lt;h2 id=&quot;1-LinearLayout（线性布局）&quot;&gt;&lt;a href=&quot;#1-LinearLayout（线性布局）&quot; class=&quot;headerl</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/01/04/%E7%AC%94%E8%AE%B0/SQL/sql%E4%B8%AD%E6%9C%80%E9%87%8D%E8%A6%81%E7%9A%84DDL%E8%AF%AD%E5%8F%A5/"/>
    <id>http://example.com/2022/01/04/%E7%AC%94%E8%AE%B0/SQL/sql%E4%B8%AD%E6%9C%80%E9%87%8D%E8%A6%81%E7%9A%84DDL%E8%AF%AD%E5%8F%A5/</id>
    <published>2022-01-04T15:11:12.581Z</published>
    <updated>2020-04-06T12:28:36.561Z</updated>
    
    <content type="html"><![CDATA[<ul><li><em>CREATE DATABASE</em> - 创建新数据库</li><li><em>ALTER DATABASE</em> - 修改数据库</li><li><em>CREATE TABLE</em> - 创建新表</li><li><em>ALTER TABLE</em> - 变更（改变）数据库表</li><li><em>DROP TABLE</em> - 删除表</li><li><em>CREATE INDEX</em> - 创建索引（搜索键）</li><li><em>DROP INDEX</em> - 删除索引</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;ul&gt;
&lt;li&gt;&lt;em&gt;CREATE DATABASE&lt;/em&gt; - 创建新数据库&lt;/li&gt;
&lt;li&gt;&lt;em&gt;ALTER DATABASE&lt;/em&gt; - 修改数据库&lt;/li&gt;
&lt;li&gt;&lt;em&gt;CREATE TABLE&lt;/em&gt; - 创建新表&lt;/li&gt;
&lt;li&gt;&lt;em&gt;ALTER</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/01/04/%E7%AC%94%E8%AE%B0/redis/redis/"/>
    <id>http://example.com/2022/01/04/%E7%AC%94%E8%AE%B0/redis/redis/</id>
    <published>2022-01-04T15:11:11.871Z</published>
    <updated>2020-02-11T05:01:00.220Z</updated>
    
    <content type="html"><![CDATA[<p> 主要应用还是在Linux上</p><p>redis-server.exe 启动redis的可执行文件<br>resis-cli.exe 命令行客户端<br>redistributio。windows.conf redis核心配置文件<br>reid-benchmark.exe 性能测试工具<br>redis-check-aof.exe AOF文件修复工具<br>resis-check-dump.exe RDB文件检查工具（快照持久化文件）</p><p>Redis 基本操作<br>    命令行：<br>        功能性命令<br>        清屏命令  clear<br>        帮助信息查询  help 命令<br>        退出 quit  exic<br>        获取当前系统时间 time</p><p>​        info<br>​<br>添加信息<br>​    功能：设置key：value<br>​    set name “”<br>​    get name<br>​    重复设置会覆盖<br>​<br>redis<br>​    业务数据的特殊性<br>​    作为缓存使用<br>​        1.原始业务功能设计<br>​            1.秒杀<br>​            2.618活动<br>​            3.双十一活动<br>​            4.排队购票<br>​        2.运营平台监控到突发高频次访问<br>​            突发时政要闻，被强势关注<br>​        3.高频、复杂的统计数据<br>​            在线人数<br>​    附加功能<br>​        系统功能优化或升级<br>​            1.单服务器升级集群<br>​            2.Session管理<br>​            3.Token管理<br>​    数据类型<br>​    1.String<br>​    2.hash     HashMap<br>​    3.list     LinkedList<br>​    4.set      HashSet<br>​    5.sorted_set   TreeSet<br>​<br>redis 存储格式<br>​    redistribution自身是一个Map，其中所有的数据都是采用key:value 的形式储存<br>​    数据类型是指存储的数据的类型，也就是value部分的类型，key部分永远都是字符串<br>​<br>​<br>String<br>​    单个数据，一个存储空间一个数据、<br>​    set key value<br>​    get key<br>​    del key<br>​    </p><pre><code>mset key1 value1 key2 value2....      m--&gt;Nutiplemget key1 key2...获取字符长度   strlen key追加 信息到原始信息后面append key value扩展操作    inor key    inorby key increment    incrbyfloat key increment设置数值数据减少范围的值    decr key    decrby key increment设置数据具有指定的生命周期    setex key seconds value    psetex key milliseconds value</code></pre><p>hash 类型数据的基本操作<br>​    1.添加/修改数据<br>​        hset key fieiId value<br>​    2.获取数据<br>​        hget key fieiId<br>​        hgetall key<br>​    3.删除数据<br>​        hdel key fieiId [fieiId2]<br>​    4.添加/修改多个数据<br>​        hmset key fieId1 value1 fieId2 value2<br>​    5.获取多个数据<br>​        hmset key  fieId1 fieId2<br>​    5.获取哈希表中字段的数量<br>​        hlen key<br>​    6. 获取哈希表中是否存在指定的字段<br>​        hexsts key fieId<br>​    7.获取哈希表中所有的字段名或字段值<br>​        hkeys key<br>​        value key<br>​    8.设置指定字段的数值数据增加范围的值<br>​        hincrby key dieId increment<br>​        hincrbyfloat key dieId increment<br>​    hsetnx key fieId value 避免覆盖<br>​<br>​<br>​    set类型<br>​        存储大量的数据类型，在查询方面提供更高的效率<br>​        能够保存大量的数据，高效的内部存储机制，便于查询<br>​        与hash存储结构完全相同，仅存键，不存值值，并且值是不允许重复的<br>​<br>​        添加数据<br>​            asdd key  member1 [member2]<br>​        获取全部数据<br>​            smember key<br>​        删除数据<br>​            srem key member [member2]<br>​        获取数据集合的总量<br>​            scard key<br>​        判断集合中是否包含指定数据<br>​            sismember key member1<br>​        随机获取集合中指定数量的数据<br>​            srandmember key [count]<br>​        数据获取集合中的某个数据并将该数据移出集合<br>​            spop key<br>​<br>        扩展操作<br>            求两个集合的交、并、差<br>                sinter key1 key2<br>                sun key1 key2<br>                sdiff key1<br>            求两个集合的交、并、差，并储存在指定的集合中<br>                sinterstore destination key1 key2<br>                sunterstore destination key1 key2<br>                sdiffstore destination key1 key2<br>            将指定数据从原始集合中移动到目标集合中<br>                smove scurce destination member</p><pre><code>sorted_set 基本操作    1.添加数据        zadd key sorce1 member1 [sorce2 member2]    2.获取全部数据        zrange key start stop [WIThSCORES]        zrevrange key start stop [WIThSCORES]    3.删除数据        zrem key member [member...]    3.按条件获取数据        zrangebyscore key min max [WIThSCORES] [LIMIT]        zrevrangebysscore key max min [WIThSCORES]    4.条件删除数据        zremrangebyrank key start stop        zremrangescore key min max    5.获取集合数据总量        zcard key        zcount key min max    6.集合交、并操作        zinterstore destination numkeys key [key...]        zunionstore destination numkeys key [key...]    7.获取数据索引 对应的索引        zrank key member        zreevrank key member    8.score值获取与修改        zscore key member        zinorby key increment member        key的通用操作    1.删除指定key        del key    2.获取key是否存在        exists key    3.获取key 的类型        tepy keykey扩展操作（时效性0）    1.为指定key设置有效期        expire key seconds        pexpire key milliseconds        expireat key timestamp        pexpireat key milliseconds    2.获取key的有效时间        ttl key   存在返回-1 存在有时间返回时间 不存在-2        pttl key    3.切换 key从时效性转为永久        persist keykey扩展操作（查询模式）    keys pattern   （keys * 查看所有）key其他操作    1.为key改名        rename key newkey (key存在的话  可能造成数据丢失)        renaenx key newkey    2.对所有key排序        sort    3.其他key通用操作        help @generic</code></pre><p>​<br>​    数据库通用指令<br>​        db 基本操作<br>​            1. 切换数据库<br>​                select index<br>​            2.其他操作<br>​                quit    退出<br>​                ping    服务连通性<br>​                echo message   控制台输出<br>​<br>​            3.数据移动<br>​                move key db   （移动后删除）<br>​            4.数据清除<br>​                dbsize<br>​                flushdb<br>​                flushall<br>​<br>​    save指令相关配置<br>​        dbfilename dump.rdb 设置本地数据库文件名，默认dump.rdb<br>​        dir 设置存储.edb文件的路径<br>​        rdbcompression yes 是否采用压缩格式<br>​        rdbchecksum yes 是否进行RDB文件校验<br>​    bgsave 相关配置  启动一个线程  后台进行保存<br>​        stop-writes-on-bgsave-error yes<br>​<br>​    save启动方式  —save配置<br>​        配置<br>​            save second change<br>​        作用<br>​            满足限定时间范围类key的变化数量到达指定数量即进行持久化<br>​        参数<br>​            second：监控时间范围<br>​            change:监控key的变化量</p><p>​    RDB的优缺点<br>​    <img src="G:\笔记\redis\image\RDB的优缺点.png" alt="1581245668099">    AOF：<br>​        不写全数据，仅记录部分数据；改为记录数据为记录操作过程；对所有操作均进行记录，排除丢失数据的风险    </p><pre><code>AOF写数据三种策略</code></pre><p>​        always （每次）<br>​            每次写入操作均同步到AOF文件中，数据零误差，性能差<br>​        everysec （每秒）默认<br>​            每秒将缓存中的指令同步到AOF文件中，数据准确性高，性能差<br>​            系统宕机的情况下丢失一秒的数据<br>​        no（系统控制）<br>​            由操作系统控制每次同步到AOF文件的周期，整体不可控<br>​    AOF功能开启<br>​        配置<br>​            <strong>appendonly</strong> yes|no<br>​        作用<br>​            是否开启AOF持久化功能，默认为不开启<br>​        配置<br>​            <strong>appenfsync</strong> always|everysec|no<br>​        作用<br>​            AOF写文件策略<br>​        配置<br>​            <strong>appendfilename</strong> filenme<br>​        作用<br>​            设置文件名<br>​        配置<br>​            <strong>dir</strong><br>​        作用<br>​            AOF持久化文件保存路径，与RDB持久化文件保持一致即可<br>​    AOF重写方式<br>​        手动重写<br>​            bgrewriteaof<br>​        自动重写<br>​            <strong>auto-aof-rewrite-min-size</strong> size<br>​            <strong>auto-aof-rewrite-percentage</strong> percentage    </p><p>AOF自动从写方式<br>            <img src="C:\Users\10155\AppData\Roaming\Typora\typora-user-images\1581250179464.png" alt="1581250179464"></p><p>RDB与AOF的选择<br>    <img src="G:\笔记\redis\image\RDB与AOF的选择.png" alt="1581250774317"></p><p>事务的基本操作<br>    1.开启事务<br>        multi<br>    2.执行事务<br>        exec<br>    3.取消事务<br>        discard</p><p>​    基于特定条件的事务执行——锁<br>​        对key添加监视，在执行exec前如果key发生了变化，终止事务执行<br>​            watch key1 [key2]<br>​        取消对所有key的监视<br>​            unwatch</p><p>​    基于特定条件的事务执行——分布式锁<br>​        使用settnx设置一个公共锁<br>​            <strong>setnx</strong> lock-key value<br>​            通过删除进行释放</p><p>​    基于特定条件的事务执行——分布式锁改良<br>​        expire lock-key second<br>​        pexpire lock-key milliseconds<br><img src="G:\笔记\redis\image\分布式锁改良.png" alt="1581254525535"></p><p>​    Redis删除策略<br>​        1.定时删除，当key的过期时间到达，有定时器立即删除；cup压力大，节约内存<br>​        2.惰性删除，数据到达过期时间，不做处理。等下次访问该数据时。与上相反<br>​        3.定期删除，随机挑选W个key配置<br>​            <strong>ACTIVE_EXPIRE_CYCLE_LOOKUPS_PER_LOOP</strong>    count </p><p>​        逐出算法，当数据进入时内存不足，会清理空间。清理失败返回错误<br>​            最大可用内存配置<br>​                <strong>maxmemory</strong><br>​            每次选取待删除数据个数<br>​                <strong>maxmemory-samples</strong><br>​            删除策略<br>​                <strong>maxmemory-policy</strong> volatile-lru<br>​                    检测易失数据（可能会过期的数据集server.db[i].expires）<br>​                    1.volatile-lru: 挑选最近最少使用的数据淘汰<br>​                    2.volatile-lfu：挑选最近使用次数最少的数据淘汰<br>​                    3.volatile-ttl：挑选将要过期的数据淘汰<br>​                    4.volatile-random：任意选择数据淘汰<br>​                    检测全库数据（所有数据集server.db[i].dict）<br>​                        allkeys-lru:挑选最近最少使用的数据淘汰<br>​                        allkeys-lfu:挑选最近使用次数最少的数据淘汰<br>​                        allkeys-random:任意选择数据淘汰<br>​                    放弃数据驱逐<br>​                        8.no-enviction（驱逐）：禁止驱逐数据（redis4.0中默认策略），会引发错误OOM（Out of Memory）</p><p>​    服务器基础配置<br>​        服务器设定<br>​            设置服务器以守护进程的方式运行<br>​                <strong>daemonize</strong> yes|no<br>​            绑定主机<br>​                <strong>bind</strong> 127.0.0.0<br>​            设置服务器端口号<br>​                <strong>port</strong> 6379<br>​            设置数据库数量<br>​                <strong>database</strong> 16<br>​        日志配置<br>​            设置服务器一指定日志记录级别<br>​                <strong>loglevel</strong> debug|<strong>verbose</strong>|notice|warning<br>​            日志记录文件名<br>​                <strong>logfile</strong> 端口号.log<br>​        客户端配置<br>​            设置同一时间最大客户端连接数，默认无限制。当客户连接到达上限，Redistribution会关闭新的连接<br>​                maxclients 0<br>​            客户端闲置等待最长时间，到达最大值后关闭连接。如需关闭，设置为0；<br>​                timeout 300<br>​        多服务器快捷配置<br>​            导入并加载指定配置文件信息，用于快速创建redis公共配置较多的redid实例配置文件，便于维护<br>​                include /path/server-端口号.conf</p><p>高级数据类型<br>    Bitmaps类型的基础操作<br>        获取指定key对应偏移量上的bit值<br>            <strong>getbit</strong> key offset<br>        设置 指定key对应偏移量上的bit值，value只能是1或0<br>            <strong>setbit</strong> key offset value<br>    Bitmaps类型的扩展操作<br>        对指定key按位进行交、并、非、异或操作，并将结果保存到destKey中<br>            <strong>bitop</strong> op destKey key1 [key….]<br>                and、or、not、xor<br>        统计指定key中1的数量<br>            <strong>bitcount</strong> key [start end]</p><p>​    HyperLogLog 基数统计； 统计不重复<br>​        添加数据<br>​            <strong>pfadd</strong> key element [element]<br>​        统计数据<br>​            <strong>pfcount</strong> key [key…]<br>​        合并数据<br>​            <strong>pfmerge</strong> destkey sourcekey [sourcekey …]<br>​    HyperLogLog相关说明<br><img src="G:\笔记\redis\image\HyperLogLog相关说明.png" alt="1581315109060"></p><p>​    GEO类型的基本操作<br>​        添加坐标<br>​            geoadd key longitude latitude member [longitu latitude member …]<br>​        获取坐标<br>​            geopos keu member [member…]<br>​        j计算坐标距离<br>​            geodist key member1 member2 [unot]<br><img src="G:\笔记\redis\image\GEO类型基本操作.png" alt="1581315724919"><br>​    主从连接（slave连接master）<br>​        方式一：客户端发送命令<br>​            slaveof <masterip> <materport><br>​        方式二：启动服务器参数<br>​            redis-server -slaveof <masterip> <materport><br>​        方式三：服务器配置<br>​            slaveof  <masterip> <materport><br>​        slave系统消息<br>​            master_link_down_since_seconds           master 系统消息<br>​            masterhost                        slave_listening_port(多个)<br>​            masterport<br>​    授权访问<br>​        master配置文件设置密码<br>​            <strong>requirepass</strong> <password><br>​        master客户端发送命令设置密码<br>​            <strong>config</strong> set requirepass <password><br>​            <strong>config</strong> get requirepass<br>​        slave客户端发送命令设置密码<br>​            <strong>auth</strong><password><br>​        slave配置文件设置密码<br>​            <strong>masterauth</strong> <password><br>​        启动客户端设置密码<br>​            <strong>redis-cli</strong> -a <password></p><p>​    数据同步阶段工作流程<br><img src="G:\笔记\redis\image\数据同步阶段工作流程.png" alt="1581328506812"></p><p>​    数据同步阶段master说明<br> <img src="G:\笔记\redis\image\数据同步阶段master说明.png" alt="1581331282081"></p><p>​    数据同步阶段slave说明   slave最好对外不提供写的功能<br><img src="G:\笔记\redis\image\数据同步阶段slave说明.png" alt="1581331488345"></p><p>服务器运行ID<br><img src="G:\笔记\redis\image\服务器运行ID.png" alt="1581331754523"></p><p>复制缓冲区内部工作原理<br><img src="G:\笔记\redis\image\复制缓冲区内部工作原理.png" alt="1581332332830"></p><p>复制缓冲区<br><img src="G:\笔记\redis\image\复制缓冲区.png" alt="1581332513876"></p><p>主从服务器复制偏移量（offset）<br><img src="G:\笔记\redis\image\主从服务器复制偏移量.png" alt="1581332611149"></p><p>数据同步+命令传播阶段工作流程<br><img src="G:\笔记\redis\image\数据同步+命令传播阶段工作流程.png" alt="1581333120175"></p><p>心跳机制<br><img src="G:\笔记\redis\image\心跳机制.png" alt="1581333207387"></p><p>心跳阶段注意事项<br><img src="G:\笔记\redis\image\心跳阶段注意事项.png" alt="1581333385228"></p><p>主从复制工作流程（完整）<br><img src="G:\笔记\redis\image\主从复制工作流程.png" alt="1581333618726"></p><p>频繁的全量复制<br><img src="G:\笔记\redis\image\频繁的全量复制.png" alt="1581333696719"></p><p><img src="G:\笔记\redis\image\频繁的全量复制2.png" alt="1581333914675"></p><p>频繁的网络中断<br><img src="G:\笔记\redis\image\频繁的网络中断1.png" alt="1581334139787"></p><p><img src="G:\笔记\redis\image\频繁的网络中断2.png" alt="1581334233567"></p><p>数据不一致<br><img src="G:\笔记\redis\image\数据不一致.png" alt="1581334306620"></p><p>配置哨兵</p><p><img src="G:\笔记\redis\image\配置哨兵.png" alt="1581335373019"></p><p>Cluster配置</p><p><img src="G:\笔记\redis\image\Cluster配置.png" alt="1581393314818"></p><p>Cluster节点操作指令<br><img src="G:\笔记\redis\image\Cluster节点操作指令.png" alt="1581393419074"></p><p>缓存预热<br>服务启动后快速宕机<br><img src="G:\笔记\redis\image\缓存预热问题.png" alt="1581393882575"></p><p><img src="G:\笔记\redis\image\缓存预热解决方案.png" alt="1581393922855"></p><p>缓存雪崩<br><img src="G:\笔记\redis\image\数据库服务器奔溃1.png" alt="1581394188702"></p><p><img src="G:\笔记\redis\image\缓存雪崩问题.png" alt="1581394236031"></p><p><img src="G:\笔记\redis\image\1581394723490.png" alt="1581394723490"></p><p><img src="G:\笔记\redis\image\1581395000328.png" alt="1581395000328"></p><p>缓存击穿<br><img src="G:\笔记\redis\image\1581395098163.png" alt="1581395098163"></p><p><img src="G:\笔记\redis\image\1581395164428.png" alt="1581395164428"></p><p><img src="G:\笔记\redis\image\1581395218959.png" alt="1581395218959"></p><p><img src="G:\笔记\redis\image\1581395451789.png" alt="1581395451789"></p><p>缓存穿透<br><img src="G:\笔记\redis\image\1581395570527.png" alt="1581395570527"></p><p><img src="G:\笔记\redis\image\1581395659739.png" alt="1581395659739"></p><p><img src="G:\笔记\redis\image\1581395703894.png" alt="1581395703894"></p><p><img src="G:\笔记\redis\image\1581395814713.png" alt="1581395814713"></p><p><img src="G:\笔记\redis\image\1581396150760.png" alt="1581396150760"></p><p>性能指标监控<br><img src="G:\笔记\redis\image\1581396300924.png" alt="1581396300924"></p><p><img src="G:\笔记\redis\image\1581396393168.png" alt="1581396393168"></p><p><img src="G:\笔记\redis\image\1581396550726.png" alt="1581396550726"></p><p><img src="G:\笔记\redis\image\1581396619370.png" alt="1581396619370"></p><p><img src="G:\笔记\redis\image\1581396766462.png" alt="1581396766462"></p><p><img src="G:\笔记\redis\image\1581396819992.png" alt="1581396819992"></p><p><img src="G:\笔记\redis\image\1581396845296.png" alt="1581396845296"></p><p><img src="G:\笔记\redis\image\1581397048191.png" alt="1581397048191"></p><p><img src="G:\笔记\redis\image\1581397166603.png" alt="1581397166603"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt; 主要应用还是在Linux上&lt;/p&gt;
&lt;p&gt;redis-server.exe 启动redis的可执行文件&lt;br&gt;resis-cli.exe 命令行客户端&lt;br&gt;redistributio。windows.conf redis核心配置文件&lt;br&gt;reid-benchmark.</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/01/04/%E7%AC%94%E8%AE%B0/mysql/mysql/"/>
    <id>http://example.com/2022/01/04/%E7%AC%94%E8%AE%B0/mysql/mysql/</id>
    <published>2022-01-04T15:11:11.855Z</published>
    <updated>2020-05-23T13:22:57.229Z</updated>
    
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/01/04/%E7%AC%94%E8%AE%B0/java%E5%9F%BA%E7%A1%80/%E6%8C%81%E4%B9%85%E5%8C%96/"/>
    <id>http://example.com/2022/01/04/%E7%AC%94%E8%AE%B0/java%E5%9F%BA%E7%A1%80/%E6%8C%81%E4%B9%85%E5%8C%96/</id>
    <published>2022-01-04T15:11:11.840Z</published>
    <updated>2020-04-06T12:28:36.941Z</updated>
    
    <content type="html"><![CDATA[<ol><li><p>对象的持久化（Persistence）</p><p>对象的持久化就是让对象的生存期超越使用对象的运行期。将对象存储在可持久保存的存储介质上，在实际应用中，运用相应的对象持久化框架，将业务数据以对象的方式保存在数据库中。在一定周期内保持不变就是持久化,持久化是针对时间来说的。数据库中的数据就是持久化了的数据,只要你不去删除或修改。比如在IE浏览器中一次Session会话中Session对象变量也是不变的,是Session容器中持久化。对象持久化的方式有很多种,根据周期不同有,page,Session,Application。</p><p><strong>简单的说就是让对象长久保存</strong></p><p>持久化是一种对象服务，就是把内存中的对象保存到外存中，让以后能够取回，需要实现3个接口：</p><p>void Save(Object o)把一个对象保存到外存中</p><p>Object Load(object oid) 通过对象标识从外存中取回对象</p><p>boolExists(object oid) 检查外存中是否存在某个对象</p></li><li><p>对象的序列化（Serialization）</p></li></ol><p>　　JVM 向我们屏蔽了内存操作相关的信息，我们并不知道数据是以什么样的形式来存储和组织的，当对象需要进行传输时，java提供了序列化的方法方便我们对数据进行传输操作。对象序列化后的数据格式可以是二进制，可以是XML，也可以是JSON等任何格式，反序列化则是相反的操作。序列化是为了解决对象的传输问题，当传输一个对象时，则需要实现2个接口：</p><p>　　void Serialize(Stream stream,object o) 把对象序列化到流中</p><p>　　object Deserialize(Stream stream) 把流反序列化成对象</p><p>　　这种传输可以是线程之间、进程之间、内存外存之间、主机之间的，凡是可以持久化的对象都可以序列化。</p><p>　　总的来说，对象持久化和对象序列化是两个完全不同的应用场景，尽管你也可以说将一个对象序列化后存储在数据库中，但是你也不能说是对象持久化。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;ol&gt;
&lt;li&gt;&lt;p&gt;对象的持久化（Persistence）&lt;/p&gt;
&lt;p&gt;对象的持久化就是让对象的生存期超越使用对象的运行期。将对象存储在可持久保存的存储介质上，在实际应用中，运用相应的对象持久化框架，将业务数据以对象的方式保存在数据库中。在一定周期内保持不变就是持久化,持久</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/01/04/%E7%AC%94%E8%AE%B0/java%E5%9F%BA%E7%A1%80/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/"/>
    <id>http://example.com/2022/01/04/%E7%AC%94%E8%AE%B0/java%E5%9F%BA%E7%A1%80/%E5%BA%8F%E5%88%97%E5%8C%96%E4%B8%8E%E5%8F%8D%E5%BA%8F%E5%88%97%E5%8C%96/</id>
    <published>2022-01-04T15:11:11.835Z</published>
    <updated>2020-04-06T12:28:36.940Z</updated>
    
    <content type="html"><![CDATA[<p>//一旦对象保存在内存中，就是字节序列</p><p>序列化：把对象转换为字节序列的过程称为对象的序列化;把内存里面的这些对象给变成一串的字节描述的过程</p><p>反序列化：把字节序列恢复为对象的过程称为对象的反序列化</p><h3 id="需要序列化的情况"><a href="#需要序列化的情况" class="headerlink" title="需要序列化的情况"></a>需要序列化的情况</h3><ol><li>当想把内存中的对象状态保存到一个文件中或者数据库时</li><li>当想用套接字在网络上传送对象时</li><li>当通过RMI传输对象的时候</li></ol>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;//一旦对象保存在内存中，就是字节序列&lt;/p&gt;
&lt;p&gt;序列化：把对象转换为字节序列的过程称为对象的序列化;把内存里面的这些对象给变成一串的字节描述的过程&lt;/p&gt;
&lt;p&gt;反序列化：把字节序列恢复为对象的过程称为对象的反序列化&lt;/p&gt;
&lt;h3 id=&quot;需要序列化的情况&quot;&gt;&lt;a </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/01/04/%E7%AC%94%E8%AE%B0/java%E5%9F%BA%E7%A1%80/Nio/"/>
    <id>http://example.com/2022/01/04/%E7%AC%94%E8%AE%B0/java%E5%9F%BA%E7%A1%80/Nio/</id>
    <published>2022-01-04T15:11:11.825Z</published>
    <updated>2020-04-06T12:28:36.938Z</updated>
    
    <content type="html"><![CDATA[<h3 id="Buffer的capacity-position和limit"><a href="#Buffer的capacity-position和limit" class="headerlink" title="Buffer的capacity,position和limit"></a>Buffer的capacity,position和limit</h3><p>缓冲区本质上是一块可以写入数据，然后可以从中读取数据的内存。这块内存被包装成NIO Buffer对象，并提供了一组方法，用来方便的访问该块内存。</p><p>为了理解Buffer的工作原理，需要熟悉它的三个属性：</p><ul><li>capacity</li><li>position</li><li>limit</li></ul><p>position和limit的含义取决于Buffer处在读模式还是写模式。不管Buffer处在什么模式，capacity的含义总是一样的。</p><p>这里有一个关于capacity，position和limit在读写模式中的说明，详细的解释在插图后面。</p><p><img src="E:\笔记\java基础\buffers-modes.png" alt="img"></p><h3 id="Buffer的类型"><a href="#Buffer的类型" class="headerlink" title="Buffer的类型"></a>Buffer的类型</h3><p>Java NIO 有以下Buffer类型</p><ul><li>ByteBuffer</li><li>MappedByteBuffer</li><li>CharBuffer</li><li>DoubleBuffer</li><li>FloatBuffer</li><li>IntBuffer</li><li>LongBuffer</li><li>ShortBuffer<br>如你所见，这些Buffer类型代表了不同的数据类型。换句话说，就是可以通过char，short，int，long，float 或 double类型来操作缓冲区中的字节。</li></ul><h3 id="Buffer的分配"><a href="#Buffer的分配" class="headerlink" title="Buffer的分配"></a>Buffer的分配</h3><p>要想获得一个Buffer对象首先要进行分配。 每一个Buffer类都有一个allocate方法。下面是一个分配48字节capacity的ByteBuffer的例子。</p><table><thead><tr><th><code>1</code></th><th><code>ByteBuffer buf = ByteBuffer.allocate(``48``);</code></th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><p>这是分配一个可存储1024个字符的CharBuffer：</p><table><thead><tr><th><code>2</code></th><th><code>CharBuffer buf = CharBuffer.allocate(``1024``);</code></th></tr></thead><tbody><tr><td></td><td></td></tr></tbody></table><h4 id="flip-方法"><a href="#flip-方法" class="headerlink" title="flip()方法"></a>flip()方法</h4><p>flip方法将Buffer从写模式切换到读模式。调用flip()方法会将position设回0，并将limit设置成之前position的值。</p><p>换句话说，position现在用于标记读的位置，limit表示之前写进了多少个byte、char等 —— 现在能读取多少个byte、char等。</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;Buffer的capacity-position和limit&quot;&gt;&lt;a href=&quot;#Buffer的capacity-position和limit&quot; class=&quot;headerlink&quot; title=&quot;Buffer的capacity,position和limit&quot;&gt;</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/01/04/%E7%AC%94%E8%AE%B0/java%E5%9F%BA%E7%A1%80/IO/"/>
    <id>http://example.com/2022/01/04/%E7%AC%94%E8%AE%B0/java%E5%9F%BA%E7%A1%80/IO/</id>
    <published>2022-01-04T15:11:11.815Z</published>
    <updated>2020-04-06T12:28:36.937Z</updated>
    
    <content type="html"><![CDATA[<h3 id="流的概念"><a href="#流的概念" class="headerlink" title="流的概念"></a>流的概念</h3><p>​    流是一组有顺序得了，有起点的字节集合，是对数据传输的总称或抽象。即数据在两设备间的传输称为流，流的本质是数据传输，根据数据传输特性将流抽象为各种类，方便更直观的进行数据操作。</p><h3 id="IO流的分类"><a href="#IO流的分类" class="headerlink" title="IO流的分类"></a>IO流的分类</h3><ol><li>处理数据类型不同分为：字符流和字节流</li><li>根据数据流向的不同分为：输入流和输出流</li></ol><h3 id="字符流和字节流"><a href="#字符流和字节流" class="headerlink" title="字符流和字节流"></a>字符流和字节流</h3><p>字符流的由来： 因为数据编码的不同，而有了对字符进行高效操作的流对象。本质其实就是基于字节流读取时，去查了指定的码表。 字节流和字符流的区别：</p><ul><li>读写单位不同：字节流以字节（8bit）为单位，字符流以字符为单位，根据码表映射字符，一次可能读多个字节。</li><li>处理对象不同：字节流能处理所有类型的数据（如图片、avi等），而字符流只能处理字符类型的数据。</li><li>字节流：一次读入或读出是8位二进制。</li><li>字符流：一次读入或读出是16位二进制。</li></ul><p><strong>设备上的数据无论是图片或者视频，文字，它们都以二进制存储的。二进制的最终都是以一个8位为数据单元进行体现，所以计算机中的最小数据单元就是字节。意味着，字节流可以处理设备上的所有数据，所以字节流一样可以处理字符数据。</strong></p><p><strong>结论：只要是处理纯文本数据，就优先考虑使用字符流。 除此之外都使用字节流。</strong></p><h3 id="输入字节流-InputStream"><a href="#输入字节流-InputStream" class="headerlink" title="输入字节流 InputStream"></a>输入字节流 InputStream</h3><ul><li><code>InputStream</code> 是所有的输入字节流的父类，它是一个抽象类。</li><li><code>ByteArrayInputStream</code>、<code>StringBufferInputStream</code>、<code>FileInputStream</code> 是三种基本的介质流，它们分别从<code>Byte 数组</code>、<code>StringBuffer</code>、和<code>本地文件</code>中读取数据。</li><li><code>PipedInputStream</code> 是从与其它线程共用的管道中读取数据，与Piped 相关的知识后续单独介绍。</li><li><code>ObjectInputStream</code> 和所有<code>FilterInputStream</code> 的子类都是装饰流（装饰器模式的主角）。</li></ul><h3 id="输出字节流-OutputStream"><a href="#输出字节流-OutputStream" class="headerlink" title="输出字节流 OutputStream"></a>输出字节流 OutputStream</h3><ul><li><code>OutputStream</code> 是所有的输出字节流的父类，它是一个抽象类。</li><li><code>ByteArrayOutputStream</code>、<code>FileOutputStream</code> 是两种基本的介质流，它们分别向<code>Byte 数组</code>、和<code>本地文件</code>中写入数据。</li><li><code>PipedOutputStream</code> 是向与其它线程共用的管道中写入数据。</li><li><code>ObjectOutputStream</code> 和所有<code>FilterOutputStream</code> 的子类都是装饰流。</li></ul><h4 id="总结："><a href="#总结：" class="headerlink" title="总结："></a><strong>总结：</strong></h4><ul><li>输入流：InputStream或者Reader：从文件中读到程序中；</li><li>输出流：OutputStream或者Writer：从程序中输出到文件中；</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;h3 id=&quot;流的概念&quot;&gt;&lt;a href=&quot;#流的概念&quot; class=&quot;headerlink&quot; title=&quot;流的概念&quot;&gt;&lt;/a&gt;流的概念&lt;/h3&gt;&lt;p&gt;​    流是一组有顺序得了，有起点的字节集合，是对数据传输的总称或抽象。即数据在两设备间的传输称为流，流的本质是数据传输，</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/01/04/%E7%AC%94%E8%AE%B0/dubbo/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/"/>
    <id>http://example.com/2022/01/04/%E7%AC%94%E8%AE%B0/dubbo/%E5%88%86%E5%B8%83%E5%BC%8F%E7%B3%BB%E7%BB%9F/</id>
    <published>2022-01-04T15:11:11.562Z</published>
    <updated>2020-04-04T12:11:43.435Z</updated>
    
    <content type="html"><![CDATA[<p><img src="G:\笔记\dubbo\分布式系统图解一.png" alt="1586002181583"></p><p><img src="G:\笔记\dubbo\img\分布式系统图解二.png" alt="1586002265988"></p>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;img src=&quot;G:\笔记\dubbo\分布式系统图解一.png&quot; alt=&quot;1586002181583&quot;&gt;&lt;/p&gt;
&lt;p&gt;&lt;img src=&quot;G:\笔记\dubbo\img\分布式系统图解二.png&quot; alt=&quot;1586002265988&quot;&gt;&lt;/p&gt;
</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/01/04/%E7%AC%94%E8%AE%B0/%E6%B4%BB%E5%8A%A8%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/"/>
    <id>http://example.com/2022/01/04/%E7%AC%94%E8%AE%B0/%E6%B4%BB%E5%8A%A8%E7%9A%84%E7%94%9F%E5%91%BD%E5%91%A8%E6%9C%9F/</id>
    <published>2022-01-04T15:11:08.258Z</published>
    <updated>2020-04-06T12:28:36.947Z</updated>
    
    <content type="html"><![CDATA[<h2 id="返回栈："><a href="#返回栈：" class="headerlink" title="返回栈："></a>返回栈：</h2><p>​    Android是使用任务（Task）来管理活动的，一个任务就是一组存放在栈里的活动的集合，这个栈就是返回栈。先进后出</p><p><img src="E:\笔记\img\返回栈示意图.png" alt="1555384291543"></p><h2 id="活动的状态："><a href="#活动的状态：" class="headerlink" title="活动的状态："></a>活动的状态：</h2><ol><li>运行状态：处于返回栈顶</li><li>暂停状态：不处于栈顶，依旧可见（不是每个活动都会占满屏幕；如：对话框形式的活动）</li><li>停止状态：不处于栈顶，不可见</li><li>销毁状态：从栈中移除</li></ol><h2 id="活动的生命周期："><a href="#活动的生命周期：" class="headerlink" title="活动的生命周期："></a>活动的生命周期：</h2><ol><li>完整生存期： onCreate()方法和onDestroy()方法之间</li><li>可见生存期：活动在onStart()方法和stop()方法之间</li><li>前台生存期：onResume方法和onPause()方法之间</li></ol><p><img src="E:\笔记\img\活动的生命周期示意图.png" alt="1555384983193"></p><p>注：当活动被回收，返回栈中已经没有这个活动将从onCreate方法中启动；此时之前的临时数据将消失；Activity中提供了一个onSaveInstanceState回调方法，可以保证在活动被回收之前一定会被调用，因此可以通过这个方法解决活动被回收是临时数据得不到保存的问题；在onSaveInstanceState中保存数据，在onCreate中恢复数据</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;返回栈：&quot;&gt;&lt;a href=&quot;#返回栈：&quot; class=&quot;headerlink&quot; title=&quot;返回栈：&quot;&gt;&lt;/a&gt;返回栈：&lt;/h2&gt;&lt;p&gt;​    Android是使用任务（Task）来管理活动的，一个任务就是一组存放在栈里的活动的集合，这个栈就是返回栈。先进后</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/01/04/%E7%AC%94%E8%AE%B0/%E6%B4%BB%E5%8A%A8%E7%9A%84%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/"/>
    <id>http://example.com/2022/01/04/%E7%AC%94%E8%AE%B0/%E6%B4%BB%E5%8A%A8%E7%9A%84%E5%90%AF%E5%8A%A8%E6%A8%A1%E5%BC%8F/</id>
    <published>2022-01-04T15:11:08.253Z</published>
    <updated>2020-04-06T12:28:36.946Z</updated>
    
    <content type="html"><![CDATA[<h2 id="活动的启动模式："><a href="#活动的启动模式：" class="headerlink" title="活动的启动模式："></a>活动的启动模式：</h2><ol><li><h3 id="standard："><a href="#standard：" class="headerlink" title="standard："></a>standard：</h3><p>默认启动模式，每当启动一个新的活动，它就会在返回栈中入栈，并处于栈顶，系统不会判断返回栈中是否存在，每次都会创建一个新的实例</p><p>通过FirstAcitiviy的自启和backfanhui</p><p><img src="E:\笔记\img\standard模式示意图.png" alt="1555391823858"></p></li><li><h3 id="singleTop："><a href="#singleTop：" class="headerlink" title="singleTop："></a>singleTop：</h3><p>如果返回栈顶已经是该活动，则认为可以直接使用它，不会在创建新的活动实例；当活动不处于栈顶还是会创建新的实例</p><p><img src="E:\笔记\img\singleTop模式示意图.png" alt="1555392533231"></p></li><li><h3 id="singleTask："><a href="#singleTask：" class="headerlink" title="singleTask："></a>singleTask：</h3><p>这个实例只会存在一个</p><p><img src="E:\笔记\img\singleTask模式示意图.png" alt="1555392688037"></p></li><li><h3 id="singleInstance："><a href="#singleInstance：" class="headerlink" title="singleInstance："></a>singleInstance：</h3><p>使用这个模式会启用一个新的返回栈来管理这个活动；实现活动共享</p><p><img src="E:\笔记\img\singleInstance模式示意图.png" alt="1555393229712"></p><p><strong>注：</strong>在AndroidManifest。xml中通过给<activity>标签指定Android:launchmade属性来选择启动模式</p></li></ol><p><img src="E:\笔记\img\启动模式设置.png" alt="1555392382693"></p><h1 id="知晓当前处于哪一个活动"><a href="#知晓当前处于哪一个活动" class="headerlink" title="知晓当前处于哪一个活动"></a>知晓当前处于哪一个活动</h1><p>​    创建一个新的Activity继承AndCompatActivity并且不需要注册，在其中打印当前活动名；让其他activity继承这个Activity</p>]]></content>
    
    
      
      
    <summary type="html">&lt;h2 id=&quot;活动的启动模式：&quot;&gt;&lt;a href=&quot;#活动的启动模式：&quot; class=&quot;headerlink&quot; title=&quot;活动的启动模式：&quot;&gt;&lt;/a&gt;活动的启动模式：&lt;/h2&gt;&lt;ol&gt;
&lt;li&gt;&lt;h3 id=&quot;standard：&quot;&gt;&lt;a href=&quot;#standard：&quot; </summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/01/04/%E7%AC%94%E8%AE%B0/%E5%B9%BF%E6%92%AD%E6%9C%BA%E5%88%B6/"/>
    <id>http://example.com/2022/01/04/%E7%AC%94%E8%AE%B0/%E5%B9%BF%E6%92%AD%E6%9C%BA%E5%88%B6/</id>
    <published>2022-01-04T15:11:08.246Z</published>
    <updated>2020-04-06T12:28:36.945Z</updated>
    
    <content type="html"><![CDATA[<p><strong>广播：</strong> 是一种可以跨进程的通信方式，因此在我们应用程序内发送出的广播，其他的应用程序也是可以收到的</p><p>注册广播的方式一般是：</p><ol><li>代码中注册；这种方式的是动态注册</li><li>AndroidMantest.xml中注册；这种称为静态注册</li></ol><h3 id="动态注册监听网络变化"><a href="#动态注册监听网络变化" class="headerlink" title="动态注册监听网络变化"></a>动态注册监听网络变化</h3><p>​    添加权限信息：</p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.ACCESS_NETWORK_STATE&quot;</span> /&gt;</span></span><br></pre></td></tr></table></figure><p>代码样例</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br><span class="line">16</span><br><span class="line">17</span><br><span class="line">18</span><br><span class="line">19</span><br><span class="line">20</span><br><span class="line">21</span><br><span class="line">22</span><br><span class="line">23</span><br><span class="line">24</span><br><span class="line">25</span><br><span class="line">26</span><br><span class="line">27</span><br><span class="line">28</span><br><span class="line">29</span><br><span class="line">30</span><br><span class="line">31</span><br><span class="line">32</span><br><span class="line">33</span><br><span class="line">34</span><br><span class="line">35</span><br><span class="line">36</span><br><span class="line">37</span><br><span class="line">38</span><br><span class="line">39</span><br><span class="line">40</span><br><span class="line">41</span><br><span class="line">42</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">MainActivity</span> <span class="keyword">extends</span> <span class="title">AppCompatActivity</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="keyword">private</span> IntentFilter intentFilter;</span><br><span class="line">    <span class="keyword">private</span> NetworkChangReceiver networkChangReceiver;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onCreate</span><span class="params">(Bundle savedInstanceState)</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onCreate(savedInstanceState);</span><br><span class="line">        setContentView(R.layout.activity_main);</span><br><span class="line"></span><br><span class="line">        intentFilter = <span class="keyword">new</span> IntentFilter();</span><br><span class="line">        <span class="comment">//当网络变化是，系统发出的正是一条android.net.conn.CONNECTIVITY_)CHANGE的广播</span></span><br><span class="line">        intentFilter.addAction(<span class="string">&quot;android.net.conn.CONNECTIVITY_)CHANGE&quot;</span>);</span><br><span class="line">        networkChangReceiver = <span class="keyword">new</span> NetworkChangReceiver();</span><br><span class="line"></span><br><span class="line">        registerReceiver(networkChangReceiver,intentFilter);<span class="comment">//对广播进行注册</span></span><br><span class="line"></span><br><span class="line">    &#125;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">protected</span> <span class="keyword">void</span> <span class="title">onDestroy</span><span class="params">()</span> </span>&#123;</span><br><span class="line">        <span class="keyword">super</span>.onDestroy();</span><br><span class="line">        unregisterReceiver(networkChangReceiver);<span class="comment">//注销广播</span></span><br><span class="line">    &#125;</span><br><span class="line">    <span class="class"><span class="keyword">class</span> <span class="title">NetworkChangReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span></span>&#123;</span><br><span class="line">        <span class="meta">@Override</span></span><br><span class="line">        <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">           <span class="comment">// Toast.makeText(context,&quot;network changes&quot;,Toast.LENGTH_SHORT).show();</span></span><br><span class="line"></span><br><span class="line">            <span class="comment">//获取连接管理器</span></span><br><span class="line">            ConnectivityManager connectivityManager = (ConnectivityManager) getSystemService(Context.CONNECTIVITY_SERVICE);</span><br><span class="line">            <span class="comment">//获取网络信息</span></span><br><span class="line">            NetworkInfo networkInfo = connectivityManager.getActiveNetworkInfo();</span><br><span class="line">            <span class="comment">//networkInfo.isAvailable()判断当前连接是否连接</span></span><br><span class="line">            <span class="keyword">if</span>(networkInfo != <span class="keyword">null</span> &amp;&amp; networkInfo.isAvailable())&#123;</span><br><span class="line">                Toast.makeText(context,<span class="string">&quot;network is available&quot;</span>,Toast.LENGTH_SHORT).show();</span><br><span class="line">            &#125;<span class="keyword">else</span>&#123;</span><br><span class="line">                Toast.makeText(context,<span class="string">&quot;network unavailable&quot;</span>,Toast.LENGTH_SHORT).show();</span><br><span class="line">            &#125;</span><br><span class="line">        &#125;</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure><h3 id="静态注册广播"><a href="#静态注册广播" class="headerlink" title="静态注册广播"></a>静态注册广播</h3><p>​      可以使程序在未启动的情况下接收到广播，当接受到广播时可以在onReceive方法里执行相应的逻辑，从而实现开机启动功能</p><p><img src="E:\笔记\创建静态广播.png" alt="1555468107697"></p><p>Exported 属性表示是否允许这个广播接受本程序以外的广播</p><p>Enabled属性表示是否启动这个广播接收器</p><h4 id="注册广播"><a href="#注册广播" class="headerlink" title="注册广播"></a>注册广播</h4><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">receiver</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:name</span>=<span class="string">&quot;.BootCompleteReceiver&quot;</span>//具体哪一个广播接收器</span></span><br><span class="line"><span class="tag">           <span class="attr">android:enabled</span>=<span class="string">&quot;true&quot;</span></span></span><br><span class="line"><span class="tag">           <span class="attr">android:exported</span>=<span class="string">&quot;true&quot;</span>&gt;</span></span><br><span class="line">           <span class="tag">&lt;<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">               <span class="tag">&lt;<span class="name">action</span> <span class="attr">android:name</span>=<span class="string">&quot;android.intent.action.BOOT_COMPLETED&quot;</span>/&gt;</span></span><br><span class="line">           <span class="tag">&lt;/<span class="name">intent-filter</span>&gt;</span></span><br><span class="line">       <span class="tag">&lt;/<span class="name">receiver</span>&gt;</span></span><br></pre></td></tr></table></figure><p><strong>添加权限</strong></p><figure class="highlight xml"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line"><span class="tag">&lt;<span class="name">uses-permission</span> <span class="attr">android:name</span>=<span class="string">&quot;android.permission.RECEIVE_BOOT_COMPLETED&quot;</span>/&gt;</span></span><br></pre></td></tr></table></figure><p>静态广播都是在<receiver>标签中注册</p><p>系统启动完成后会发出一条值为android.intent.action.BOOT_COMPLETED的广播</p><p><strong>注</strong> 不要在onReceive()方法上添加过多的逻辑或者进行任何耗时操作</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br></pre></td><td class="code"><pre><span class="line"><span class="keyword">public</span> <span class="class"><span class="keyword">class</span> <span class="title">BootCompleteReceiver</span> <span class="keyword">extends</span> <span class="title">BroadcastReceiver</span> </span>&#123;</span><br><span class="line"></span><br><span class="line">    <span class="meta">@Override</span></span><br><span class="line">    <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onReceive</span><span class="params">(Context context, Intent intent)</span> </span>&#123;</span><br><span class="line">        Toast.makeText(context,<span class="string">&quot;Boot Comlete&quot;</span>, Toast.LENGTH_SHORT);</span><br><span class="line">    &#125;</span><br><span class="line">&#125;</span><br></pre></td></tr></table></figure>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;&lt;strong&gt;广播：&lt;/strong&gt; 是一种可以跨进程的通信方式，因此在我们应用程序内发送出的广播，其他的应用程序也是可以收到的&lt;/p&gt;
&lt;p&gt;注册广播的方式一般是：&lt;/p&gt;
&lt;ol&gt;
&lt;li&gt;代码中注册；这种方式的是动态注册&lt;/li&gt;
&lt;li&gt;AndroidMante</summary>
      
    
    
    
    
  </entry>
  
  <entry>
    <title></title>
    <link href="http://example.com/2022/01/04/%E7%AC%94%E8%AE%B0/Service/"/>
    <id>http://example.com/2022/01/04/%E7%AC%94%E8%AE%B0/Service/</id>
    <published>2022-01-04T15:11:08.221Z</published>
    <updated>2020-04-06T12:28:36.563Z</updated>
    
    <content type="html"><![CDATA[<p>Service可以有两种启动方式：一种是startService()，另一种是bindService()。第二种启动方式才会用到onBind()方法</p><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br><span class="line">15</span><br></pre></td><td class="code"><pre><span class="line"><span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">onClick</span><span class="params">(View v)</span> </span>&#123;</span><br><span class="line">       <span class="keyword">switch</span> (v.getId()) &#123;</span><br><span class="line">           <span class="keyword">case</span> R.id.button1_start_service:</span><br><span class="line">               Intent startIntent = <span class="keyword">new</span> Intent(<span class="keyword">this</span>,MyService.class);</span><br><span class="line">               startService(startIntent);</span><br><span class="line">               <span class="keyword">break</span>;</span><br><span class="line">            <span class="keyword">case</span> R.id.button2_stop_service:</span><br><span class="line">                Intent stopIntent =<span class="keyword">new</span> Intent(<span class="keyword">this</span>,MyService.class);</span><br><span class="line">                stopService(stopIntent);</span><br><span class="line">                <span class="keyword">break</span>;</span><br><span class="line">           <span class="keyword">default</span>:</span><br><span class="line">                 <span class="keyword">break</span>;</span><br><span class="line">       &#125;</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="停止服务的方法"><a href="#停止服务的方法" class="headerlink" title="停止服务的方法"></a>停止服务的方法</h2><ol><li>在外部使用stopService()方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br></pre></td><td class="code"><pre><span class="line">stopService(stopIntent);</span><br></pre></td></tr></table></figure><ol start="2"><li>在服务内部（onStartCommand方法内部)使用stopSelf()方法</li></ol><figure class="highlight java"><table><tr><td class="gutter"><pre><span class="line">1</span><br><span class="line">2</span><br><span class="line">3</span><br><span class="line">4</span><br><span class="line">5</span><br><span class="line">6</span><br><span class="line">7</span><br><span class="line">8</span><br><span class="line">9</span><br><span class="line">10</span><br><span class="line">11</span><br><span class="line">12</span><br><span class="line">13</span><br><span class="line">14</span><br></pre></td><td class="code"><pre><span class="line"><span class="comment">//服务执行时操作</span></span><br><span class="line">   <span class="meta">@Override</span></span><br><span class="line">   <span class="function"><span class="keyword">public</span> <span class="keyword">int</span> <span class="title">onStartCommand</span><span class="params">(Intent intent, <span class="keyword">int</span> flags, <span class="keyword">int</span> startId)</span> </span>&#123;</span><br><span class="line">       Log.d(TAG,<span class="string">&quot;onStartCommand&quot;</span>);</span><br><span class="line"></span><br><span class="line">       <span class="keyword">new</span> Thread(<span class="keyword">new</span> Runnable() &#123;</span><br><span class="line">           <span class="meta">@Override</span></span><br><span class="line">           <span class="function"><span class="keyword">public</span> <span class="keyword">void</span> <span class="title">run</span><span class="params">()</span> </span>&#123;</span><br><span class="line">               <span class="comment">//处理具体的逻辑</span></span><br><span class="line">               stopSelf();<span class="comment">//服务执行完毕后自动停止</span></span><br><span class="line">           &#125;</span><br><span class="line">       &#125;).start();</span><br><span class="line">       <span class="keyword">return</span> <span class="keyword">super</span>.onStartCommand(intent, flags, startId);</span><br><span class="line">   &#125;</span><br></pre></td></tr></table></figure><h2 id="onStartCommand方法的返回值："><a href="#onStartCommand方法的返回值：" class="headerlink" title="onStartCommand方法的返回值："></a>onStartCommand方法的返回值：</h2><p>onStartCommand方法执行时，返回的是一个int型。这个整型可以有三个返回值：START_NOT_STICKY、START_STICKY、START_REDELIVER_INTENT</p><ul><li>START_NOT_STICKY:“非粘性的”。使用这个返回值时，如果在执行完onStartCommand方法后，服务被异常kill掉，系统不会自动重启该服务。</li><li>START_STICKY：如果Service进程被kill掉，保留Service的状态为开始状态，但不保留递送的intent对象。随后系统会尝试重新创建Service，由于服务状态为开始状态，所以创建服务后一定会调用onStartCommand(Intent,int,int)方法。如果在此期间没有任何启动命令被传递到Service，那么参数Intent将为null。</li><li>START_REDELIVER_INTENT：重传Intent。使用这个返回值时，系统会自动重启该服务，并将Intent的值传入。</li></ul>]]></content>
    
    
      
      
    <summary type="html">&lt;p&gt;Service可以有两种启动方式：一种是startService()，另一种是bindService()。第二种启动方式才会用到onBind()方法&lt;/p&gt;
&lt;figure class=&quot;highlight java&quot;&gt;&lt;table&gt;&lt;tr&gt;&lt;td class=&quot;gutte</summary>
      
    
    
    
    
  </entry>
  
</feed>
